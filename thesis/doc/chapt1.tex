\section{Теоретическая часть}

\subsection{История функционального программирования}
\label{sec:hist}

В 60-х гг. XX в. $\lambda$-исчисление начало привлекать интерес группы исседователей вне сообщества логиков -- ученых, занимавшихся теорией и практикой языков программирования.

С 1956 по 1960 Джон Маккарти из США разрабатывал язык программирования Лисп \cite{mccarthy1965lisp} для обработки списков с возможностью определения абстракций посредством функций. Целью Маккарти было применение Лиспа к проблемам нечислового вычисления, и особенно к новой области искусственного интеллекта, а также способствовать новому стилю организации программ, ныне называемым функциональным программированием.

В начале 60-х гг. в Англии Питер Ландин предложил использовать $\lambda$-термы для кодирования конструкций языка программирования Алгол-60. \cite{landin1965correspondence} Если в случае Лиспа точному соответствию с $\lambda$-исчислением препятствовала динамическая область видимости, то в случае с Алголом блочная структура точно соответствовала связыванию имен в $\lambda$-исчислении. Фактически работа Ландина позволила взглянуть на само $\lambda$-исчисление как на язык программирования, причем особенно подходящий для теоретических целей. В дальнейшем Ландин предложил язык программирования ISWIM, \cite{landin1966next} который стал предшественником языков семейства ML.

В 1978 Бэкус определил FP (язык комбинаторов и аппарат, в рамках которого возможно размышлять о программах) в своей лекции по случаю вручения Премии Тьюринга. \cite{backus2007can} Эта лекция привлекла внимание к области функционального программирования.

В середине 70-х гг. XX в. исследователи Университета г. Эдинбурга (Гордон, Милнер и др.) работали над системой автоматизированного доказательства теорем под названием LCF. \cite{gordon1979edinburgh} Система состояла из дедуктивного исчисления $PP\lambda$ (полиморфное предикатное $\lambda$-исчисление), а также интерактивного языка программирования ML (от meta-language, т.е. \textit{мета-язык}), использовавшегося для описания стратегий поиска доказальств, инспирированный языком ISWIM (близком к $\lambda$-исчислению) и обладающий оригинальной системой типов. Вскоре обнаружилось, что этот язык можно применять в качестве языка программирования общего назначения.

\subsection{$\lambda$-исчисление}
\label{sec:lam}

Формальная система, ныне называемая $\lambda$-исчислением была изобретена логиком Алонзо Чёрчем в 20-х гг. XX в. Его целью являлось разработка более естественного основания для логики, чем теория типов Рассела или теория множеств Цермело. Он решил взять функцию в качестве основы, в примитивы входили \emph{абстракция} и \emph{аппликация}. Бестиповое $\lambda$-исчисление, рассматриваемое в качестве логики, оказалось противоречивым.

Работа Чёрча была мотивирована стремлением создать \emph{исчисление} (неформально под этим понмается синтаксис для термов и множество правил переписывания для их преобразования), которое бы отражало интуитивное понимание поведения \emph{функций}. Данный подход в корне отличается от рассмотрения функций как множеств (множеств пар <<аргумент, значение>>), потому что целью являлось отражение \emph{вычислительного} аспекта функций.

Абстрактный синтаксис \emph{бестипового $\lambda$-исчисления} (термин, используемый для того, чтобы отличать это исчисление от других версий $\lambda$-исчисления) включает в себя \emph{лямбда-выражения}, определяемые следующим образом:
\begin{center}
$e$ ::= $x \in V$ | $\lambda x. e$ | $e_1 e_2$
\end{center}

Множество $V$ задает имена переменных (например, $x_1$, $x_2$, и т.д.). Выражения вида $\lambda x. e$ называются \emph{абстракциями}, а $(e_1 e_2)$ --- \emph{аппликациями}. Первые отражают понятие функции, вторые --- применения функции. По соглашению операция аппликации принимается левоассоциативной, поэтому $(e_1 e_2 e_3)$ означает $((e_1 e_2) e_3)$.

Правила переписывания $\lambda$-исчисления зависят от понятия \emph{подстановки} выражения $e_1$ вместо всех свободных вхождений переменной $x$ в выражении $e_2$, записываемом как $[e_1/x]e_2$. В большинстве систем, использующих подстановку, включая и предикатное, и $\lambda$-исчисление, необходимо проявлять внимание к конфликтам имен. Из-за этого строгое формальное определение подстановки является несколько громоздким.

Чтобы понять, как выполняется подстановка, необходимо разобраться с понятием \emph{свободных переменных} в выражении $e$, которое записывается как $fv(e)$ и определяется с помощью структурной индукции по абстрактному синтаксису следующими правилами:

\begin{gather*}
fv(x) = \{x\} \\
fv(e_1 e_2) = fv(e_1) \cup fv(e_2) \\
fv(\lambda x.e) = fv(e) \setminus \{x\}
\end{gather*}

Переменную $x$ называют \emph{свободной} в выражении $e$ если и только если $x \in fv(e)$. Тогда подстановку $[e_1/x]e_2$ можно определить индуктивно следующим образом:

\begin{align*}
[e/x_i]x_j &= \begin{cases}
  e,& \text{если $i=j$} \\
  x_j,& \text{если $i \neq j$}
\end{cases} \\
[e_1/x](e_2 e_3) &= ([e_1/x]e_2)([e_1/x]e_3) \\
[e_i/x_i](\lambda x_j.e_2) &= \begin{cases}
  \lambda x_j.e_2,& \text{если $i = j$} \\
  \lambda x_j.[e_1/x_i]e_2,& \text{если $i \neq j$ и $x_j \notin fv(e_1)$} \\
  \lambda x_k.[e_1/x_i]([x_k/x_j]e_2),& \text{в ином случае, где $k \neq i$, $k \neq j$,} \\
  & \text{а также $x_k \notin fv(e_1) \cup fv(e_2)$}
\end{cases}
\end{align*}

Последнее правило таково потому, что в рассматриваемом случае может произойти конфликт имен, который разрешается переименованием связанной переменной. Следующий пример показывает все три правила в действии:
\begin{equation*}
[y/x]((\lambda y.x) (\lambda x.x) x) \equiv (\lambda z. y) (\lambda x.x) y
\end{equation*}

Определив подстановку, $\lambda$-исчисление можно завершить следующими тремя правилами переписывания:

\begin{enumerate}
\item $\alpha$-конверсия (переименование): $\lambda x_i.e \Leftrightarrow \lambda x_j.[x_j/x_i]e$, где $x_j \notin fv(e)$
\item $\beta$-конверсия (подстановка): $(\lambda x.e_1)e_2 \Leftrightarrow [e_2/x]e_1$
\item $\eta$-конверсия: $\lambda x.(e x) \Leftrightarrow e$, если $x \notin fv(e)$
\end{enumerate}

Эти правила, вместе со стандартными правилами отношения эквивалентности для рефлексивности, симметричности и транзитивности, создают теорию \emph{конвертируемости} для $\lambda$-исчисления.

Понятие \emph{редукции} является тем же самым, что и конвертируемость, но ограниченную таким образом, чтобы $\beta$-конверсия и $\eta$-конверсия применялись <<в одну сторону>>:

\begin{enumerate}
\item $\beta$-редукция: $(\lambda x.e_1)e_2 \Rightarrow [e_2/x]e_1$
\item $\eta$-редукция: $\lambda x.(e x) \Rightarrow e$, если $x \notin fv(e)$
\end{enumerate}

Пишут $e_1 \overset{*}{\Rightarrow} e_2$, если $e_1$ можно вывести из $e_2$ посредством последовательного применения одного или более правила ($\alpha$-конверсии, $\beta$- или $\eta$-редукции). Иными словами, $\overset{\ast}{\Rightarrow}$ является рефлексивным, транзитивным замыканием $\Rightarrow$, включая $\alpha$-конверсию.

Если лямбда-выражение нельзя редуцировать посредством применения $\beta$- или $\eta$-редукции, то говорят, что оно \emph{в нормальной форме}.

У некоторых выражений нет нормальной формы, например, результатом единственно возможной редукции
\begin{equation*}
(\lambda x. (x x))(\lambda x. (x x))
\end{equation*}
является идентичное выражение, вследствие чего процесс редукции не завершается.

Несмотря на это, нормальная форма является тем, что интуитивно понимают под <<значением>> выражения. Возникают естественные вопросы. Если у выражения есть нормальная форма, всегда ли можно её найти? Является ли нормальная форма выражения уникальной? Ответы на эти вопросы дают теоремы Чёрча-Россера.

Из экономии места различные теоремы (такие, как упомянутые выше теоремы, теорема о висячей точке, тезис Чёрча) не рассматриваются. За более подробным обсуждением этих и других вопросов по $\lambda$-исчислению следует обращаться к \cite{barendregt1984lambda}.

\subsection{Естественный вывод}
\label{sec:logic}

Логика высказываний формализует аргументацию, вовлекающую \emph{связки}, такие, как <<и>>, <<или>>, <<подразумевать>> и т.д. Используя связки, сложные высказывания конструируют из атомарных высказываний и переменных.

Формально абстрактный синтаксис формул определяется следующим образом:
\begin{center}
$A$ ::= $x \in V$ | $A_1 \land A_2$ | $A_1 \lor A_2$ | $A_1 \implies A_2$ | $A_1 \iff A_2$ | $\bot$ | $\neg A$
\end{center}

Множество $V$ задает имена переменных (например, $X_1$, $X_2$, и т.д.). В связки вкладывается следующий смысл:
\begin{itemize}
\item $\land$ означает \emph{и} (конъюнкция)
\item $\lor$ означает \emph{или} (дизъюнкция)
\item $\implies$ означает \emph{если} (импликация)
\item $\iff$ означает \emph{если и только если} (эквивалентность)
\item $\bot$ означает \emph{ложь}
\item $\neg$ означает \emph{отрицание}
\end{itemize}

По соглашению большими латинскими буквами ($A, B, C, \ldots$) обозначают произвольные формулы. Приоритет $\land$ выше, чем приоритет $\lor$, $\implies$, $\iff$; самый высокий приоритет у $\neg$. Операции конъюнкции и дизъюнкции левоассоциативны, импликация правоассоциативна, эквивалентность неассоциативна.

Общей формой доказательства является вывод \emph{умозаключения} на основе нескольких \emph{предпосылок}:

\begin{center}
$B_1, \ldots, B_n \vdash A$
\end{center}
что значит \emph{$A$ истинно, если все $B_1, \ldots, B_n$ истинны}. Список предпосылок $B_1, \ldots, B_2$ может быть пустым, или содержать одну или более предпосылок.

Греческими буквами $\Gamma$ и $\Delta$ обозначают произвольные списки высказываний, то есть
\begin{center}
$\Gamma$ ::= $\emptyset$ | $\Gamma, A$ | $\Gamma_1, \Gamma_2$
\end{center}

Объединение двух списков $\Gamma$ и $\Delta$ записывают $\Gamma,\Delta$ (дубликаты из обоих списков удаляются).

В системе естественного вывода каждая логическая связка характеризуется одним или более правилами \emph{введения}, которые определяют способ вывода того, что конъюнкция, импликация, и т.п. истинна. Правило \emph{устранения} связки указывает, какие истины можно получить на основании истинности конъюнкции, импликации и т.п. Правила введения и устранения иметь некоторые свойства, чтобы гарантировать \emph{обоснованность} системы.

Первое правило
$$\infer{A \vdash A}{}$$
означает простую тавтологию: если $A$ истинно, то оно истинно.

Введение импликации записывают:
$$\infer{\Gamma \vdash B \implies A}{\Gamma, B \vdash A}$$

С интуитивной точки зрения, это правило отражает метод условного доказательства: если из $\Gamma$ и $B$ можно вывести $A$, то из $\Gamma$ можно вывести $B \implies A$.

Правило \emph{modus ponens} записывают
$$\infer{\Gamma, \Delta \vdash A}{\Gamma \vdash B \implies A & \Delta \vdash B}$$

Первая предпосылка указывает, что из истинности $B$ следует истинность $A$ если предпосылки $\Gamma$ истинны. Вторая предпосылка указывает, что $B$ истинно при условии, что предпосылки $\Delta$ истинны, а заключение указывает, что $A$ истинно в том случае, когда предпосылки $\Gamma,\Delta$ истинны.

Правила для введения и устранения конъюнкции определяются следующим образом:

$$
\infer[введение конъюнкции]
  {\Gamma, \Delta \vdash A \land B}{\Gamma \vdash A & \Delta \vdash B}
\qquad
\infer[устранение конъюнкции №1]
  {\Gamma \vdash A}{\Gamma \vdash A \land B}
\qquad
\infer[устранение конъюнкции №2]
  {\Gamma \vdash B}{\Gamma \vdash A \land B}
$$

Правило $\land$-введения утверждает, что если из предпосылок $\Gamma$ следует $A$, а из предпосылок $\Delta$ следует $B$, то из сложенных списков $\Gamma,\Delta$ можно вывести $A \land B$. Правило $\land$-устранения №1 указывает, что если из $\Gamma$ следует $A \land B$, то значит, из $\Gamma$ можно вывести и $A$. Правило $\land$-устранения №2 аналогично правилу №1.

Остальные связки определяются подобным образом. За более полным изложением следует обращаться к \cite{mendelson1997introduction}.
